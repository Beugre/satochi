#!/usr/bin/env python3
"""
<<<<<<< HEAD
üîÑ PAGE COMPARISON - DONN√âES R√âELLES FIREBASE UNIQUEMENT
Comparaison de performances - AUCUNE DONN√âE TEST
=======
üîç PAGE COMPARAISON BINANCE/FIREBASE
Compare les donn√©es collect√©es par le service binance-live avec Firebase
>>>>>>> feature/clean-config
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
<<<<<<< HEAD
from datetime import datetime, timedelta
import numpy as np

st.set_page_config(
    page_title="Comparison - Satochi Bot",
    page_icon="üîÑ",
    layout="wide"
)

try:
    from firebase_config import StreamlitFirebaseConfig
except ImportError as e:
    st.error(f"‚ùå Erreur import firebase_config: {e}")
    st.stop()

class ComparisonPage:
    """Comparison - 100% DONN√âES R√âELLES FIREBASE"""
    
    def __init__(self):
        self.firebase_config = StreamlitFirebaseConfig()
    
    def run(self):
        """Comparaisons bas√©es UNIQUEMENT sur Firebase"""
        
        st.title("üîÑ Comparaison de Performances (Firebase)")
        st.markdown("### üî• COMPARAISONS R√âELLES - AUCUNE SIMULATION")
        st.markdown("---")
        
        # Auto-refresh simple (optionnel - utilisateur peut actualiser manuellement)
        auto_refresh = st.checkbox("Auto-refresh", value=False, key="comparison_auto_refresh")
        if auto_refresh:
            st.info("üîÑ Mode auto-refresh activ√© - Utilisez F5 ou le bouton üîÑ Actualiser pour rafra√Æchir")
        
        try:
            # R√©cup√©ration donn√©es R√âELLES
            trades_data = self.firebase_config.get_trades_data(limit=1000)
            
            if not trades_data:
                st.warning("üì≠ Aucune donn√©e pour comparaison dans Firebase")
                st.info("üîÑ Attendez que le bot g√©n√®re plus de donn√©es")
                return
            
            # S√©lection des p√©riodes de comparaison
            self._display_comparison_controls()
            
            # Comparaison par paires R√âELLES
            self._display_real_pairs_comparison(trades_data)
            
            # Comparaison temporelle R√âELLE
            self._display_real_time_comparison(trades_data)
            
            # Comparaison strat√©gies R√âELLE (si disponible)
            self._display_real_strategy_comparison(trades_data)
            
        except Exception as e:
            st.error(f"‚ùå Erreur comparaison Firebase: {e}")
    
    def _display_comparison_controls(self):
        """Contr√¥les de comparaison"""
        st.subheader("‚öôÔ∏è Param√®tres de Comparaison")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            self.comparison_type = st.selectbox(
                "Type de comparaison",
                ["Par Paire", "Par P√©riode", "Par Strat√©gie"],
                index=0
            )
        
        with col2:
            self.metric_type = st.selectbox(
                "M√©trique principale",
                ["P&L Total", "Winrate", "Profit Factor", "Sharpe Ratio"],
                index=0
            )
        
        with col3:
            self.time_period = st.selectbox(
                "P√©riode d'analyse",
                ["7 derniers jours", "30 derniers jours", "Tout l'historique"],
                index=1
            )
    
    def _display_real_pairs_comparison(self, trades_data):
        """Comparaison par paires R√âELLES"""
        st.subheader("üìä Comparaison par Paire (Firebase)")
        
        try:
            df = pd.DataFrame(trades_data)
            
            if 'symbol' not in df.columns or 'pnl' not in df.columns:
                st.warning("üìä Donn√©es symbol/pnl manquantes")
                return
            
            # Groupement par paire
            pair_stats = df.groupby('symbol').agg({
                'pnl': ['sum', 'mean', 'count', 'std'],
                'symbol': 'count'
            }).round(4)
            
            pair_stats.columns = ['PnL Total', 'PnL Moyen', 'Nb Trades', 'Volatilit√©', 'Total']
            pair_stats = pair_stats.drop('Total', axis=1)
            
            # Calcul Winrate par paire
            winrates = df.groupby('symbol').apply(
                lambda x: (x['pnl'] > 0).sum() / len(x) * 100
            ).round(1)
            pair_stats['Winrate %'] = winrates
            
            # Calcul Profit Factor par paire
            def calculate_profit_factor(group):
                wins = group[group['pnl'] > 0]['pnl'].sum()
                losses = abs(group[group['pnl'] < 0]['pnl'].sum())
                return wins / losses if losses > 0 else float('inf')
            
            profit_factors = df.groupby('symbol').apply(calculate_profit_factor).round(2)
            pair_stats['Profit Factor'] = profit_factors
            
            # Tri par m√©trique s√©lectionn√©e
            sort_column_map = {
                "P&L Total": "PnL Total",
                "Winrate": "Winrate %",
                "Profit Factor": "Profit Factor",
                "Sharpe Ratio": "PnL Moyen"  # Approximation
            }
            sort_column = sort_column_map.get(self.metric_type, "PnL Total")
            pair_stats = pair_stats.sort_values(sort_column, ascending=False)
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.dataframe(pair_stats, use_container_width=True)
            
            with col2:
                # Graphique de comparaison
                fig = px.bar(
                    x=pair_stats.index,
                    y=pair_stats[sort_column],
                    title=f"{self.metric_type} par Paire (Firebase)",
                    labels={'y': self.metric_type, 'x': 'Paire'}
                )
                fig.update_layout(height=400)
                st.plotly_chart(fig, use_container_width=True)
            
        except Exception as e:
            st.error(f"‚ùå Erreur comparaison paires: {e}")
    
    def _display_real_time_comparison(self, trades_data):
        """Comparaison temporelle R√âELLE"""
        st.subheader("‚è∞ Comparaison Temporelle (Firebase)")
        
        try:
            df = pd.DataFrame(trades_data)
            
            if 'timestamp' not in df.columns or 'pnl' not in df.columns:
                st.warning("üìä Donn√©es timestamp/pnl manquantes")
                return
            
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            # Filtrage par p√©riode
            if self.time_period == "7 derniers jours":
                cutoff = datetime.now() - timedelta(days=7)
                df = df[df['timestamp'] > cutoff]
            elif self.time_period == "30 derniers jours":
                cutoff = datetime.now() - timedelta(days=30)
                df = df[df['timestamp'] > cutoff]
            
            if len(df) == 0:
                st.info("üì≠ Aucune donn√©e dans la p√©riode s√©lectionn√©e")
                return
            
            # Comparaison par jour
            df['date'] = df['timestamp'].dt.date
            daily_stats = df.groupby('date').agg({
                'pnl': ['sum', 'mean', 'count']
            }).round(2)
            
            daily_stats.columns = ['PnL Total', 'PnL Moyen', 'Nb Trades']
            daily_stats['Winrate %'] = df.groupby('date').apply(
                lambda x: (x['pnl'] > 0).sum() / len(x) * 100
            ).round(1)
            
            col1, col2 = st.columns(2)
            
            with col1:
                # Graphique √©volution journali√®re
                fig = px.bar(
                    x=daily_stats.index,
                    y=daily_stats['PnL Total'],
                    title="P&L Journalier (Firebase)",
                    color=daily_stats['PnL Total'],
                    color_continuous_scale=['red', 'gray', 'green']
                )
                fig.update_layout(height=400)
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                # Graphique winrate journalier
                fig = px.line(
                    x=daily_stats.index,
                    y=daily_stats['Winrate %'],
                    title="Winrate Journalier (Firebase)",
                    markers=True
                )
                fig.add_hline(y=50, line_dash="dash", line_color="gray")
                fig.update_layout(height=400)
                st.plotly_chart(fig, use_container_width=True)
            
            # Table des stats journali√®res
            st.dataframe(daily_stats.sort_index(ascending=False), use_container_width=True)
            
        except Exception as e:
            st.error(f"‚ùå Erreur comparaison temporelle: {e}")
    
    def _display_real_strategy_comparison(self, trades_data):
        """Comparaison strat√©gies R√âELLE"""
        st.subheader("üéØ Comparaison Strat√©gies (Firebase)")
        
        try:
            df = pd.DataFrame(trades_data)
            
            # V√©rifier si on a des donn√©es de strat√©gie
            if 'strategy' in df.columns:
                strategy_stats = df.groupby('strategy').agg({
                    'pnl': ['sum', 'mean', 'count', 'std']
                }).round(4)
                
                strategy_stats.columns = ['PnL Total', 'PnL Moyen', 'Nb Trades', 'Volatilit√©']
                
                # Calculs additionnels
                winrates = df.groupby('strategy').apply(
                    lambda x: (x['pnl'] > 0).sum() / len(x) * 100
                ).round(1)
                strategy_stats['Winrate %'] = winrates
                
                st.dataframe(strategy_stats, use_container_width=True)
                
                # Graphique comparaison strat√©gies
                fig = px.bar(
                    x=strategy_stats.index,
                    y=strategy_stats['PnL Total'],
                    title="P&L par Strat√©gie (Firebase)"
                )
                st.plotly_chart(fig, use_container_width=True)
                
            else:
                # Analyse par type de trade (BUY/SELL)
                if 'side' in df.columns:
                    side_stats = df.groupby('side').agg({
                        'pnl': ['sum', 'mean', 'count']
                    }).round(4)
                    
                    side_stats.columns = ['PnL Total', 'PnL Moyen', 'Nb Trades']
                    
                    winrates = df.groupby('side').apply(
                        lambda x: (x['pnl'] > 0).sum() / len(x) * 100
                    ).round(1)
                    side_stats['Winrate %'] = winrates
                    
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.dataframe(side_stats, use_container_width=True)
                    
                    with col2:
                        fig = px.pie(
                            values=side_stats['PnL Total'],
                            names=side_stats.index,
                            title="R√©partition P&L par Type (Firebase)"
                        )
                        st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("üìä Pas de donn√©es de strat√©gie ou de side disponibles")
            
        except Exception as e:
            st.error(f"‚ùå Erreur comparaison strat√©gies: {e}")

# Lancement de la page
if __name__ == "__main__":
    page = ComparisonPage()
    page.run()
=======
from plotly.subplots import make_subplots
import sys
import os
from datetime import datetime, timedelta
import json

# Ajouter le r√©pertoire parent au path
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

try:
    from firebase_logger import FirebaseLogger
    from config import APIConfig
except ImportError as e:
    st.error(f"‚ùå Erreur import: {e}")
    st.stop()


class BinanceFirebaseComparison:
    """Classe pour comparer les donn√©es Binance/Firebase"""
    
    def __init__(self):
        self.firebase_logger = None
        self.setup_firebase()
        
    def setup_firebase(self):
        """Configuration Firebase"""
        try:
            self.firebase_logger = FirebaseLogger()
            if hasattr(self.firebase_logger, 'db') and self.firebase_logger.db:
                st.success("üî• Firebase connect√© avec succ√®s")
            else:
                st.error("‚ùå Erreur connexion Firebase")
        except Exception as e:
            st.error(f"‚ùå Erreur Firebase: {e}")
    
    def get_binance_live_data(self):
        """R√©cup√®re les donn√©es de la collection binance_live"""
        try:
            if not self.firebase_logger or not self.firebase_logger.db:
                return None, None, None, None
            
            # Account info
            account_doc = self.firebase_logger.db.collection('binance_live').document('account_info').get()
            account_data = account_doc.to_dict() if account_doc.exists else None
            
            # Recent trades
            trades_doc = self.firebase_logger.db.collection('binance_live').document('recent_trades').get()
            trades_data = trades_doc.to_dict() if trades_doc.exists else None
            
            # Open orders
            orders_doc = self.firebase_logger.db.collection('binance_live').document('open_orders').get()
            orders_data = orders_doc.to_dict() if orders_doc.exists else None
            
            # Health status
            health_doc = self.firebase_logger.db.collection('binance_live').document('health').get()
            health_data = health_doc.to_dict() if health_doc.exists else None
            
            return account_data, trades_data, orders_data, health_data
            
        except Exception as e:
            st.error(f"‚ùå Erreur r√©cup√©ration donn√©es binance_live: {e}")
            return None, None, None, None
    
    def get_bot_trades_data(self):
        """R√©cup√®re les donn√©es des trades du bot principal"""
        try:
            if not self.firebase_logger or not self.firebase_logger.db:
                return []
            
            # R√©cup√©rer les trades des derni√®res 24h
            trades_ref = self.firebase_logger.db.collection('trades')
            trades_query = trades_ref.order_by('timestamp', direction='DESCENDING').limit(100)
            trades_docs = trades_query.get()
            
            trades_data = []
            for doc in trades_docs:
                trade = doc.to_dict()
                trade['id'] = doc.id
                trades_data.append(trade)
            
            return trades_data
            
        except Exception as e:
            st.error(f"‚ùå Erreur r√©cup√©ration trades bot: {e}")
            return []
    
    def display_service_status(self, health_data):
        """Affiche le statut du service binance-live"""
        st.subheader("üîç Statut du Service Binance Live")
        
        if not health_data:
            st.error("‚ùå Aucune donn√©e de sant√© trouv√©e")
            st.info("üí° Le service binance-live n'est peut-√™tre pas d√©marr√©")
            return
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            status = health_data.get('status', 'unknown')
            if status == 'healthy':
                st.metric("üü¢ Statut", "En ligne")
            else:
                st.metric("üî¥ Statut", "Hors ligne")
        
        with col2:
            cycle_count = health_data.get('cycle_count', 0)
            st.metric("üîÑ Cycles", cycle_count)
        
        with col3:
            pairs_count = health_data.get('monitored_pairs_count', 0)
            st.metric("üìä Paires", pairs_count)
        
        with col4:
            last_check = health_data.get('timestamp', 'Inconnu')
            if last_check != 'Inconnu':
                try:
                    check_time = datetime.fromisoformat(last_check)
                    time_ago = datetime.now() - check_time
                    if time_ago.total_seconds() < 300:  # 5 minutes
                        st.metric("‚è∞ Derni√®re v√©rif", "R√©cente")
                    else:
                        st.metric("‚ö†Ô∏è Derni√®re v√©rif", f"Il y a {int(time_ago.total_seconds()/60)}min")
                except:
                    st.metric("‚è∞ Derni√®re v√©rif", "Inconnue")
            else:
                st.metric("‚è∞ Derni√®re v√©rif", "Inconnue")
    
    def display_account_comparison(self, account_data):
        """Compare les informations de compte"""
        st.subheader("üíº Comparaison des Comptes")
        
        if not account_data:
            st.error("‚ùå Aucune donn√©e de compte Binance Live trouv√©e")
            return
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**üìä Donn√©es Binance Live**")
            
            balances = account_data.get('balances', [])
            if balances:
                df_binance = pd.DataFrame(balances)
                df_binance = df_binance[df_binance['total'] > 0].sort_values('total', ascending=False)
                
                # Affichage des principales balances
                st.dataframe(
                    df_binance[['asset', 'free', 'locked', 'total']],
                    use_container_width=True,
                    height=300
                )
                
                total_value = account_data.get('total_value_usdc_approx', 0)
                st.metric("üí∞ Valeur totale (approx)", f"{total_value:.2f} USDC")
            else:
                st.info("Aucune balance trouv√©e")
        
        with col2:
            st.write("**ü§ñ Donn√©es Bot Trading**")
            
            # Ici on pourrait r√©cup√©rer les donn√©es du bot principal
            # Pour l'instant, affichage placeholder
            st.info("üîÑ Int√©gration avec les donn√©es du bot principal √† venir")
            
            # M√©tadonn√©es du compte Binance Live
            st.write("**‚ÑπÔ∏è M√©tadonn√©es**")
            can_trade = account_data.get('canTrade', False)
            can_withdraw = account_data.get('canWithdraw', False)
            account_type = account_data.get('accountType', 'Unknown')
            
            st.write(f"‚Ä¢ Trading autoris√©: {'‚úÖ' if can_trade else '‚ùå'}")
            st.write(f"‚Ä¢ Retrait autoris√©: {'‚úÖ' if can_withdraw else '‚ùå'}")
            st.write(f"‚Ä¢ Type de compte: {account_type}")
    
    def display_trades_comparison(self, trades_data, bot_trades):
        """Compare les trades collect√©s vs les trades du bot"""
        st.subheader("üîÑ Comparaison des Trades")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**üìä Trades Binance Live (Derni√®res 6h)**")
            
            if trades_data and trades_data.get('trades'):
                binance_trades = trades_data['trades']
                
                # Statistiques
                total_trades = len(binance_trades)
                buy_trades = len([t for t in binance_trades if t.get('isBuyer', False)])
                sell_trades = total_trades - buy_trades
                
                col1a, col1b, col1c = st.columns(3)
                col1a.metric("üìà Total", total_trades)
                col1b.metric("üü¢ Achats", buy_trades)
                col1c.metric("üî¥ Ventes", sell_trades)
                
                # DataFrame des trades r√©cents
                if binance_trades:
                    df_binance_trades = pd.DataFrame(binance_trades[:20])  # 20 derniers
                    if not df_binance_trades.empty:
                        display_cols = ['symbol', 'price', 'qty', 'time', 'isBuyer']
                        available_cols = [col for col in display_cols if col in df_binance_trades.columns]
                        st.dataframe(
                            df_binance_trades[available_cols],
                            use_container_width=True,
                            height=300
                        )
            else:
                st.info("Aucun trade collect√© dans les derni√®res 6h")
        
        with col2:
            st.write("**ü§ñ Trades du Bot (Derni√®res 24h)**")
            
            if bot_trades:
                # Statistiques des trades du bot
                bot_total = len(bot_trades)
                completed_trades = len([t for t in bot_trades if t.get('status') == 'COMPLETED'])
                
                col2a, col2b = st.columns(2)
                col2a.metric("üìä Total Bot", bot_total)
                col2b.metric("‚úÖ Compl√©t√©s", completed_trades)
                
                # DataFrame des trades du bot
                df_bot_trades = pd.DataFrame(bot_trades[:20])
                if not df_bot_trades.empty:
                    display_cols = ['pair', 'side', 'price', 'quantity', 'status']
                    available_cols = [col for col in display_cols if col in df_bot_trades.columns]
                    st.dataframe(
                        df_bot_trades[available_cols],
                        use_container_width=True,
                        height=300
                    )
            else:
                st.info("Aucun trade du bot trouv√©")
    
    def display_orders_comparison(self, orders_data):
        """Affiche les ordres ouverts"""
        st.subheader("üìã Ordres Ouverts")
        
        if not orders_data or not orders_data.get('orders'):
            st.info("Aucun ordre ouvert trouv√©")
            return
        
        orders = orders_data['orders']
        
        col1, col2, col3 = st.columns(3)
        
        # Statistiques des ordres
        total_orders = len(orders)
        buy_orders = len([o for o in orders if o.get('side') == 'BUY'])
        sell_orders = len([o for o in orders if o.get('side') == 'SELL'])
        
        col1.metric("üìä Total ordres", total_orders)
        col2.metric("üü¢ Ordres d'achat", buy_orders)
        col3.metric("üî¥ Ordres de vente", sell_orders)
        
        # DataFrame des ordres
        if orders:
            df_orders = pd.DataFrame(orders)
            display_cols = ['symbol', 'side', 'type', 'price', 'origQty', 'status']
            available_cols = [col for col in display_cols if col in df_orders.columns]
            
            st.dataframe(
                df_orders[available_cols],
                use_container_width=True
            )
    
    def display_sync_analysis(self, trades_data, bot_trades):
        """Analyse de synchronisation entre Binance et Firebase"""
        st.subheader("üîÑ Analyse de Synchronisation")
        
        if not trades_data or not bot_trades:
            st.warning("‚ö†Ô∏è Donn√©es insuffisantes pour l'analyse de synchronisation")
            return
        
        binance_trades = trades_data.get('trades', [])
        
        # Analyse temporelle
        now = datetime.now()
        last_binance_sync = trades_data.get('timestamp', '')
        
        try:
            last_sync_time = datetime.fromisoformat(last_binance_sync)
            sync_delay = (now - last_sync_time).total_seconds() / 60  # en minutes
            
            col1, col2, col3 = st.columns(3)
            
            col1.metric("‚è∞ Derni√®re sync", f"{sync_delay:.1f} min")
            col2.metric("üìä Trades Binance", len(binance_trades))
            col3.metric("ü§ñ Trades Bot", len(bot_trades))
            
            # Indicateur de sant√© de la sync
            if sync_delay < 5:
                st.success("üü¢ Synchronisation en temps r√©el")
            elif sync_delay < 15:
                st.warning("üü° L√©ger d√©lai de synchronisation")
            else:
                st.error("üî¥ D√©lai de synchronisation important")
                
        except ValueError:
            st.error("‚ùå Erreur dans l'analyse temporelle")
    
    def run(self):
        """Interface principale de la page"""
        st.title("üîç Comparaison Binance ‚Üî Firebase")
        st.markdown("Compare les donn√©es collect√©es en temps r√©el avec les trades du bot")
        
        # R√©cup√©ration des donn√©es
        with st.spinner("üì° R√©cup√©ration des donn√©es..."):
            account_data, trades_data, orders_data, health_data = self.get_binance_live_data()
            bot_trades = self.get_bot_trades_data()
        
        # Onglets pour organiser l'affichage
        tab1, tab2, tab3, tab4 = st.tabs(["üîç Statut", "üíº Comptes", "üîÑ Trades", "üìã Ordres"])
        
        with tab1:
            self.display_service_status(health_data)
            
            # Boutons d'action
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("üîÑ Actualiser les donn√©es"):
                    st.rerun()
            
            with col2:
                if st.button("üìä V√©rifier le service"):
                    if health_data:
                        st.success("‚úÖ Service binance-live op√©rationnel")
                    else:
                        st.error("‚ùå Service binance-live non d√©tect√©")
            
            with col3:
                if st.button("‚ö° Forcer une collecte"):
                    st.info("üîÑ Fonctionnalit√© √† venir - D√©clenchement manuel de collecte")
        
        with tab2:
            self.display_account_comparison(account_data)
        
        with tab3:
            self.display_trades_comparison(trades_data, bot_trades)
            self.display_sync_analysis(trades_data, bot_trades)
        
        with tab4:
            self.display_orders_comparison(orders_data)
        
        # Footer avec informations de debug
        with st.expander("üîß Informations de debug"):
            st.write("**Donn√©es brutes (extrait):**")
            debug_data = {
                'health_status': health_data.get('status') if health_data else None,
                'account_balances_count': len(account_data.get('balances', [])) if account_data else 0,
                'binance_trades_count': len(trades_data.get('trades', [])) if trades_data else 0,
                'bot_trades_count': len(bot_trades),
                'open_orders_count': len(orders_data.get('orders', [])) if orders_data else 0
            }
            st.json(debug_data)


# Interface Streamlit
def main():
    st.set_page_config(
        page_title="Comparaison Binance/Firebase",
        page_icon="üîç",
        layout="wide"
    )
    
    comparison = BinanceFirebaseComparison()
    comparison.run()


if __name__ == "__main__":
    main()
>>>>>>> feature/clean-config
